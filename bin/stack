#!/usr/bin/env ruby

begin
  require 'cri'
rescue LoadError
  if ARGV == ['self_setup']
    puts 'Installing cri gem...'
    system '/usr/bin/env gem install cri -v 2.10.1'
    puts "Done! Now try 'stack help'"

    exit
  else
    abort "ERROR: Fire 'stack self_setup' to install one gem dependency. " \
          "Batteries mostly included!"
  end
end

require 'pathname'
require 'open3'
require 'tempfile'
require 'forwardable'

trap('INT') { exit }


## Generic classes ##


module Ui
  module_function

  def dialog(message)
    loop do
      answer = do_dialog(message)

      yield if answer == 'y'

      break if %w(y n).include?(answer)
    end
  end

  def dialog!(message)
    loop do
      answer = do_dialog(message)

      break if answer == 'y'

      abort
    end
  end

  def do_dialog(message)
    print "#{message} (Y/n) "

    answer = gets.downcase.chomp
    answer = 'y' if answer.empty?
    answer
  end

end


module GitQuery
  def branch
    capture('symbolic-ref --short HEAD')
  end

  def ref
    capture('rev-parse HEAD')
  end

  def commit_count
    capture('rev-list HEAD | wc -l').to_i
  end

  def working_directory_clean?
    diff_name_only.empty?
  end

  def last_stash_id(query)
    capture("stash list | grep '#{query}' | head -1").split(':').first
  end

  def modified_files
    diff_name_only.split("\n")
  end

  def save_stash(desc)
    capture("stash save #{desc}")
  end

  def pop_stash(id)
    capture("stash pop '#{id}'")
  end

  def stash_contents(query)
    capture("stash show #{query}")
  end

  def last_commit_message
    commit_messages(limit: 1).first
  end

  def commit_messages(limit:)
    capture("log -n #{limit} --format=%B").split("\n")
  end

  def diff_name_only
    capture('diff --name-only')
  end

  def files_of_last_commit
    capture('diff-tree --no-commit-id --name-only HEAD').split("\n")
  end

  def staged_files?
    !capture('diff --cached').empty?
  end

  private def capture(command, **options)
    git!(command, capture: true, **options)[0].to_s.chomp
  end
end


GitterOutput = Struct.new(:output, :status) do
  def success?
    return unless status

    status == true || status.exitstatus.zero?
  end

  def to_str
    output
  end
  alias_method :to_s, :to_str
end


class Gitter
  def initialize(dir = Pathname(Dir.pwd), **options)
    @dir = dir
    @options = options

    yield self if block_given?
  end

  def git(command, capture: true, dir: nil)
    git_cmd = "git -C '#{dir || @dir}' #{command}"

    if capture?(capture)
      output, status = Open3.capture2e(git_cmd)
    else
      output, status = '', system(git_cmd)
    end

    GitterOutput.new(output, status)
  end

  private def capture?(capture)
    capture || @options[:capture]
  end

  def git!(command, capture: false, dir: nil)
    output = git(command, capture: capture, dir: dir)
    fail StackError, output unless output.success?

    output
  end
end


class InteractiveGitStash
  def initialize(project)
    @project = project
  end

  def ask_to_stash
    return if modified_files.empty?

    print_status 'These files are modified', modified_files

    Ui.dialog 'Stash?' do
      with_message('Contents stashed!') { @project.save_stash(query) }
    end
  end

  private def modified_files
    @modified_files ||= @project.modified_files.map { |file| "   #{file}" }
  end

  private def print_status(*messages)
    puts "#{@project.id.to_s.upcase} - #{messages.join("\n\n")}"
    puts
  end

  private def with_message(message)
    puts
    yield
    puts message, ''
  end

  private def query
    "STACK-CLI-#{@project.branch}"
  end

  def ask_to_apply
    return if last_stash_id.nil?

    unless (stash_contents = @project.stash_contents(last_stash_id)).empty?
      print_status 'Found the following stash:', stash_contents
    end

    Ui.dialog 'Apply?' do
      with_message('Stash applied!') { @project.pop_stash(last_stash_id) }
    end
  end

  private def last_stash_id
    @project.last_stash_id(query)
  end
end


class MatchLineFileWriter
  def initialize(path)
    @path = path
  end

  def call(ref_line:)
    write yield(*find_line(ref_line))
  end

  private

  def find_line(pattern)
    lines = File.read(@path).split("\n")
    number = lines.index { |l| l =~ pattern }

    [number, lines]
  end

  def write(lines)
    File.write(@path, lines.join("\n") + "\n")
  end
end


module DataFiles
  def self.each(&block)
    read.each(&block)
  end

  def self.[](file)
    read[file]
  end

  private_class_method def self.read
    @fixtures ||= begin
      current_file = nil

      DATA.each.with_object(Hash.new { |h, k| h[k] = '' }) do |line, files|
        if line =~ /FILESTART: (.+)/
          current_file = $1
        else
          files[current_file] += line
        end
      end
    end
  end
end


## Project classes ##


APP_FOLDERS = {
  sf: 'stack-foundation',
  ss: 'stack-shops',
  sa: 'stack-admin',
  sc: 'stack-partners',
  go: 'stack-api'
}

StackError = Class.new(StandardError)


class Project
  attr_reader :id, :path

  include GitQuery

  def initialize(id, path, gitter: nil)
    @id = id
    @path = path
    @git = gitter || Gitter.new(path)
  end

  def git(*args, **options)
    @git.git(*args, **options, dir: @path)
  end

  def git!(*args, **options)
    @git.git!(*args, **options, dir: @path)
  end

  def write_file(path, contents)
    @path.join(path).write(contents)
  end

  def read_file(path)
    @path.join(path).read
  end

  def path?(path)
    path.to_s =~ /\A(#{@path}\z|#{@path}\/)/
  end

  def inspect
    %{<Project id="#{id}" path="#{path}">}
  end

  def ==(other)
    id == other.id && path?(other.path)
  end
end


class ProjectSet
  extend Forwardable

  delegate [:each, :map] => :@projects

  def initialize(projects)
    @projects = projects
  end

  def [](id)
    @projects.find { |p| p.id.to_sym == id.to_sym }
  end

  def only(*ids)
    self.class.new(@projects.select { |p| filter(ids, p) })
  end

  private def filter(ids, p)
    ids.include?(p.id) || ids.include?(:current) && p.id == current.id
  end

  def except(*ids)
    self.class.new(@projects.reject { |p| filter(ids, p) })
  end

  def with_branch(branch)
    self.class.new(@projects.select { |p| p.branch == branch })
  end

  def with_branch_different_from(branch)
    self.class.new(@projects.select { |p| p.branch != branch })
  end

  def including(*projects)
    self.class.new((projects + @projects).compact)
  end

  def same_branch_as_current
    with_branch(current.branch)
  end

  def current
    @current ||= @projects.find { |project| project.path?(Dir.pwd) }
  end

  def ==(other)
    @projects.map(&:id).sort == other.map(&:id).sort
  end

  def empty?
    @projects.empty?
  end

  def inspect
    "<ProjectSet\n#{@projects.map { |p| "   #{p.inspect}" }.join(",\n")}\n>"
  end
end


class ProjectSetBuilder
  def self.call(only: nil, **options, &block)
    new(**options).call(only: only, &block)
  end

  def initialize(**options)
    @path = ProjectPathSet.new(
      folders: options[:folders],
      basedir: options[:basedir],
      mkpath: options[:mkpath]
    )
    @gitter_options = { capture: options[:capture] }
  end

  def call(only:)
    only = only.to_s.split(',').map(&:to_sym)

    projects = @path.paths(only: only) do |*args|
      build_project(*args)
    end

    yield ProjectSet.new(projects)
  end

  private def build_project(id, path)
    gitter = Gitter.new(path, **@gitter_options)
    Project.new(id, path, gitter: gitter)
  end
end


class ProjectPathSet
  def self.folder_ids
    APP_FOLDERS.keys
  end

  def initialize(folders: nil, basedir: nil, mkpath: false)
    @folders = folders || APP_FOLDERS
    @basedir = basedir || ENV.fetch('STACK_PATH')
    @mkpath = mkpath
  end

  def paths(only: [])
    only = folder_ids if only.empty?
    invalid = only - folder_ids

    fail StackError, "Invalid project IDs: #{invalid}" if invalid.any?

    only = ([:sf] + only).uniq

    @folders
      .select { |id, _| only.include?(id) }
      .map do |id, folder|
        path = path_for(folder)
        path.mkpath if @mkpath

        block_given? ? yield(id, path) : path
      end
  end

  private def folder_ids
    @folders.keys
  end

  private def path_for(name)
    path = Pathname(@basedir) + name
    path.exist? && path.realpath || path
  end

  def valid_current_path?
    paths.find { |path| path.exist? && Dir.pwd.start_with?(path.to_s) }
  end
end


class FoundationRefChanger
  def initialize(project, foundation)
    @project = project
    @foundation = foundation
    @gemfile = MatchLineFileWriter.new(project.path + 'Gemfile')
    @gemfile_lock = MatchLineFileWriter.new(project.path + 'Gemfile.lock')
  end

  def call
    change_gemfile_ref
    change_gemfile_lock_ref
  end

  private def change_gemfile_ref
    @gemfile.call ref_line: /gem ['"]stack_foundation['"]/ do |no, lines|
      lines[no + 1].gsub!(/branch: ['"].+['"]/, "branch: '#{@foundation.branch}'")
      lines
    end
  end

  private def change_gemfile_lock_ref
    @gemfile_lock.call ref_line: /remote: .+foundation/ do |no, lines|
      lines[no + 1].gsub!(/revision: .+\z/, "revision: #{@foundation.ref}")
      lines[no + 2].gsub!(/branch: .+\z/, "branch: #{@foundation.branch}")
      lines
    end
  end
end


## Use cases (when the CLI action gets slightly complex) ##


class SwitchBranch
  def initialize(options, branch)
    @options = options
    @branch = branch
  end

  def call
    ProjectSetBuilder.(only: @options[:only]) do |projects|
      changed = change_branches_in(projects).compact

      if changed.empty?
        abort "No branch '#{@branch}' exists in any given project"
      end

      yield changed
    end
  end

  private def change_branches_in(projects)
    projects.map do |project|
      istash = InteractiveGitStash.new(project)
      istash.ask_to_stash

      if change_branch_in(project).success?
        istash.ask_to_apply
        project.id
      end
    end
  end

  private def change_branch_in(project)
    if @options[:create]
      project.git "checkout -b #{@branch}"
    else
      project.git "checkout #{@branch}"
    end
  end
end


class BumpProjects
  def initialize(projects, options)
    @options = options
    @foundation = projects.same_branch_as_current[:sf]
    @projects = filter_projects(projects, options)
  end

  private def filter_projects(projects, options)
    if options[:all]
      projects.except(:sf).same_branch_as_current
    else
      projects.only(:current)
    end
  end

  def call
    message = fetch_commit_message

    if @foundation && @foundation.staged_files?
      yield @foundation.id
      commit_foundation message
    end

    @projects.each do |project|
      yield project.id
      bump_and_commit project, message
    end
  end

  private def fetch_commit_message
    "\"#{raw_commit_message.tr('"', "\\\"").gsub("\n\n", "\n")}\""
  end

  private def raw_commit_message
    if @options[:interactive]
      capture_commit_message
    else
      ensure_message_when_having_foundation_changes
      @options[:message] || 'Bump foundation'
    end
  end

  private def ensure_message_when_having_foundation_changes
    if @foundation && @foundation.staged_files? && !@options[:message] && !@options[:amend]
      fail StackError, 'ERROR: Provide a commit message with -m or use -i!'
    end
  end

  private def capture_commit_message
    file = Pathname(Dir.pwd) + 'COMMIT_EDITMSG'
    file.write commit_summary

    abort unless system("cd $PWD; ${EDITOR:-nano} #{file}")

    file.read.each_line.grep(/\A[^#]/).join("\n")
  ensure
    file.delete if file.exist?
  end

  private def commit_summary
    git_statuses = @projects.including(@foundation).map do |p|
      title = "## CHANGES ON #{p.id.to_s.upcase} ##"
      border = '#' * title.length
      header = "\n\n" + border + "\n" + title + "\n" + border + "\n\n"

      header + p.git('status')
    end

    git_statuses = git_statuses.join.each_line.map { |l| "# #{l}" }.join

    DataFiles['COMMIT_EDITMSG'] + git_statuses
  end

  private def commit_foundation(message)
    @foundation.git! "commit -m #{message}"
  end

  private def bump_and_commit(project, message)
    project.git 'checkout -- Gemfile Gemfile.lock'

    FoundationRefChanger.new(project, @foundation).() if @foundation

    project.git 'add Gemfile Gemfile.lock'

    if @options[:amend]
      project.git! "commit --amend --no-edit -m #{message}" if project.staged_files?
    else
      project.git! "commit -m #{message}" if project.staged_files?
    end
  end
end


## CLI interface ##


stack = Cri::Command.define do
  name 'stack'
  summary 'Utilities for dealing with Stack projects'
end

stack.define_command do
  name 'branch'
  summary 'change or create branch on all projects'

  option :c, :create, 'creates the branch on all projects', argument: :forbidden
  optional :o, :only, "list of comma-separated projects to act on, " \
                      "one of: #{ProjectPathSet.folder_ids.join(',')}"

  run do |options, (branch)|
    SwitchBranch.new(options, branch).() do |branches|
      branches_desc = branches.map(&:upcase).join(', ')

      if options[:create]
        puts "Created branch '#{branch}' on projects: #{branches_desc}"
      else
        puts "Switched to branch '#{branch}' on projects: #{branches_desc}"
      end
    end
  end
end

stack.define_command do
  name 'bump_to_develop'
  summary 'bump foundation to develop across projects'
  description 'by default it takes the projects with the same branch name as the current one'

  optional :o, :only, "list of comma-separated projects to act on, " \
                      "one of: #{ProjectPathSet.folder_ids.join(',')}"

  optional :p, :push, "also force push the branches"

  run do |options, _|
    ProjectSetBuilder.() do |projects|
      sf = projects[:sf]

      unless sf.working_directory_clean?
        Ui.dialog!('I will clean up the foundation working directory. Proceed?')
      end

      sf.git! 'reset --hard', capture: true
      sf.git! 'checkout develop', capture: true
      sf.git! 'pull --rebase origin develop', capture: true

      projects = if options[:only]
                   only = options[:only].split(',').map(&:to_sym)
                   projects.only(*only)
                 else
                   projects.except(:sf).same_branch_as_current
                 end

      if projects.empty?
        abort 'No project with these names were found'
      end

      projects.each do |project|
        FoundationRefChanger.new(project, sf).()

        puts
        puts "Bumping #{project.id.to_s.upcase} to develop"
        puts

        project.git! 'add Gemfile Gemfile.lock'

        if project.staged_files?
          project.git! 'commit --amend --no-edit'
        end

        if options[:push]
          project.git! "push -f origin #{project.branch}"
        end
      end
    end
  end
end

stack.define_command do
  name 'changeref'
  summary 'bump foundation'

  run do |_, _|
    ProjectSetBuilder.() do |projects|
      FoundationRefChanger.new(projects.current, projects[:sf]).()
      puts 'Changed foundation refs!'
    end
  end
end

stack.define_command do
  name 'bump'
  summary 'bump foundation + commit'
  description DataFiles['bump_command_description']

  option :j, :amend, 'amend', argument: :forbidden
  option :m, :message, 'provide a commit message', argument: :required
  option :i, :interactive, 'open text editor to commit', argument: :forbidden
  option :a, :all, 'bump all branches of the same name', argument: :forbidden

  run do |options, _|
    ProjectSetBuilder.() do |projects|
      count = 0

      BumpProjects.new(projects, options).call do |id|
        puts
        puts (id == :sf ? 'Commiting SF' : "Bumping #{id.to_s.upcase}")
        puts

        count += 1
      end
    end
  end
end

stack.define_command do
  name 'push'
  summary 'push all branches with the same name as the current one'

  option :f, :force, 'force push', argument: :forbidden
  option :a, :all, 'push all branches of the same name', argument: :forbidden

  run do |options, _|
    count = 0

    push_project = -> (project) do
      puts if count.nonzero?
      puts "Pushing #{project.id.upcase}..."
      puts

      command = options[:force] ? 'push -f' : 'push'

      project.git! "#{command} --set-upstream origin #{project.branch}"

      count += 1
    end

    ProjectSetBuilder.() do |projects|
      projects.same_branch_as_current.each(&push_project)
    end
  end
end

stack.define_command do
  name 'pull'
  summary 'pull all branches with the same name as the current one'

  run do |options, _|
    count = 0

    push_project = -> (project) do
      puts if count.nonzero?
      puts "Pulling #{project.id.upcase}..."
      puts

      project.git! "pull origin #{project.branch}"

      count += 1
    end

    ProjectSetBuilder.() do |projects|
      projects.same_branch_as_current.each(&push_project)
    end
  end
end

stack.define_command do
  name 'merge'
  summary 'merge current branch into argument branch (develop by default)'

  run do |_, options|
    ProjectSetBuilder.() do |projects|
      current = projects.current
      branch = options.first || 'develop'

      if current.branch == branch
        abort "ERROR: Switch to the branch you want to merge onto #{branch}"
      end

      current.git! 'fetch'
      current.git! "rebase origin/#{branch}"
      current.git! "checkout #{branch}"
      current.git! "pull origin #{branch}"
      current.git! "merge --ff #{branch}"

      puts 'Merged successfully!'
    end
  end
end

stack.define_command do
  name 'rebase'
  summary 'rebase current branch onto argument branch (develop by default)'

  run do |_, options|
    branch = options.first || 'develop'

    ProjectSetBuilder.() do |projects|
      current = projects.current

      current.git! 'fetch'
      current.git! "rebase origin/#{branch}"
      current.git! "rebase -i origin/#{branch}"
    end
  end
end

stack.define_command do
  name 'self_setup'
  summary 'set up stack command'

  run do |_, _|
    abort 'Already setup!'
  end
end

stack.define_command do
  name 'example'
  summary 'prints out a simple example workflow'

  run do |_, _|
    puts DataFiles['stack_command_description']
  end
end

stack.add_command Cri::Command.new_basic_help


## TEST SUITE ##


run_test_suite = proc do
  require 'minitest/autorun'


  ## Test helpers ##


  module TmpdirHelper
    def in_tmpdir(dir = '')
      in_tmpbasedir do |basedir|
        cd_dir basedir + dir do |dest_dir|
          yield basedir, dest_dir
        end
      end
    end

    def in_tmpbasedir
      Dir.mktmpdir do |basedir|
        basedir = Pathname(basedir).realpath

        Dir.chdir(basedir) { yield basedir }
      end
    end

    def cd_dir(dir)
      dir.mkpath

      Dir.chdir(dir) { yield dir }
    end
  end


  module GitFixtureCreator
    extend TmpdirHelper

    def self.create
      in_tmpbasedir do |basedir|
        kwargs = { basedir: basedir, capture: true, mkpath: true }

        ProjectSetBuilder.(**kwargs) do |projects|
          projects.each { |proj| commit_fixtures proj }
          yield basedir, projects
        end
      end
    end

    private_class_method def self.commit_fixtures(project)
      project.git! 'init'

      DataFiles.each do |filename, contents|
        project.write_file filename, contents
      end

      project.git! 'add .'
      project.git! "commit -m 'Commiting fixtures'"
    end
  end


  module BumpAssertions
    def gemfile_fixture(branch)
      DataFiles['Gemfile'].sub('__gemfile_branch__', branch)
    end

    def gemfile_lock_fixture(branch, revision)
      DataFiles['Gemfile.lock']
        .sub('__gemfile_lock_branch__', branch)
        .sub('__gemfile_lock_revision__', revision)
    end

    def msg(proj, msg)
      "#{proj.id.to_s.upcase} #{msg}"
    end

    def assert_ref_change(project, ref:, branch:)
      exp_gemfile_lock = gemfile_lock_fixture(branch, ref)
      exp_gemfile = gemfile_fixture(branch)

      assert_equal(
        exp_gemfile,
        project.read_file('Gemfile'),
        msg(project, 'has wrong Gemfile')
      )
      assert_equal(
        exp_gemfile_lock,
        project.read_file('Gemfile.lock'),
        msg(project, 'has wrong Gemfile.lock')
      )
    end

    def assert_bump(projects, ref:, branch:, message:)
      projects.each do |proj|
        assert proj.working_directory_clean?, msg(proj, 'is not clean')
        assert_equal 2, proj.commit_count, msg(proj, 'has wrong commit count')
        assert_ref_change proj, ref: ref, branch: branch
        assert_equal(
          message,
          proj.last_commit_message,
          msg(proj, 'has wrong commit message')
        )
      end
    end

    def assert_not_bump(projects)
      projects.each do |proj|
        assert_equal 1, proj.commit_count, msg(proj, 'has wrong commit count')
        assert_equal(
          'Commiting fixtures',
          proj.last_commit_message,
          msg(proj, 'has wrong commit message')
        )
      end
    end
  end


  module CmdHelper
    def stack_cmd(options, basedir:)
      executable = "#{Pathname(__FILE__).expand_path}"
      cmd "APP_ENV=test STACK_PATH=#{basedir} #{executable} #{options}"
    end

    def cmd(command)
      output, _ = Open3.capture2e(command)
      output.chomp
    end
  end


  ## Tests ##


  class ProjectPathSetTest < MiniTest::Test
    include TmpdirHelper

    def test_returns_paths_for_all_projects
      folders = { '1' => 'one', '2' => 'two', '6' => 'six' }
      path_set = ProjectPathSet.new(folders: folders, basedir: Dir.pwd)

      paths = path_set.paths

      assert_equal 3, paths.count
      assert_includes paths, Pathname(Dir.pwd) + 'one'
      assert_includes paths, Pathname(Dir.pwd) + 'two'
      assert_includes paths, Pathname(Dir.pwd) + 'six'
    end

    def test_returns_paths_for_some_projects
      folders = { '1' => 'one', '2' => 'two', '6' => 'six' }
      path_set = ProjectPathSet.new(folders: folders, basedir: Dir.pwd)

      paths = path_set.paths(only: ['1', '2'])

      assert_equal 2, paths.count
      assert_includes paths, Pathname(Dir.pwd) + 'one'
      assert_includes paths, Pathname(Dir.pwd) + 'two'
    end

    def test_yields_id_and_path_of_each_project_if_block_given
      folders = { '1' => 'f_one', '2' => 'f_two', '6' => 'f_six' }
      projects = {}
      path_set = ProjectPathSet.new(folders: folders, basedir: Dir.pwd)

      path_set.paths { |id, path| projects[id] = path }

      assert_equal({
        '1' => Pathname(Dir.pwd) + 'f_one',
        '2' => Pathname(Dir.pwd) + 'f_two',
        '6' => Pathname(Dir.pwd) + 'f_six'
      }, projects)
    end

    def test_path_is_valid_when_it_belongs_to_one_of_the_projects
      folders = { '1' => 'f_one', '2' => 'f_two', '6' => 'f_six' }

      folders.values do |folder|
        in_tmpdir folder do |basedir|
          folders.values.each { |f| basedir.join(f).mkpath }

          path_set = ProjectPathSet.new(folders: folders, basedir: basedir)

          assert path_set.valid_current_path?
        end
      end
    end

    def test_path_is_valid_when_it_is_a_subdirectory_of_the_project
      folders = { '1' => 'f_one', '2' => 'f_two', '6' => 'f_six' }

      folders.values do |folder|
        in_tmpdir File.join(folder, 'subdir') do |basedir|
          folders.values.each { |f| basedir.join(f).mkpath }

          path_set = ProjectPathSet.new(folders: folders, basedir: basedir)

          assert path_set.valid_current_path?
        end
      end
    end

    def test_path_is_invalid_when_it_belongs_to_no_project
      folders = { '1' => 'f_one', '2' => 'f_two', '6' => 'f_six' }

      in_tmpdir 'invalid' do |basedir|
        folders.values.each { |f| basedir.join(f).mkpath }

        path_set = ProjectPathSet.new(folders: folders, basedir: basedir)

        refute path_set.valid_current_path?
      end
    end

    def test_path_is_invalid_when_in_basedir
      folders = { '1' => 'f_one', '2' => 'f_two', '6' => 'f_six' }

      in_tmpbasedir do |basedir|
        folders.values.each { |f| basedir.join(f).mkpath }

        path_set = ProjectPathSet.new(folders: folders, basedir: basedir)

        refute path_set.valid_current_path?
      end
    end
  end


  class ProjectTest < MiniTest::Test
    def test_has_a_path_and_id
      project = Project.new(:dummy, Pathname(Dir.pwd) + 'dummy')

      assert_equal :dummy, project.id
      assert_equal Pathname(Dir.pwd) + 'dummy', project.path
    end

    def test_path_query_returns_true_when_target_path_matches_project_path
      path = Pathname(Dir.pwd) + 'dummy'
      project = Project.new(:dummy, path)

      assert project.path?(path)
      assert project.path?(path.to_s)
    end

    def test_path_returns_false_when_target_path_does_not_match_project_path
      path = Pathname(Dir.pwd) + 'dummy'
      project = Project.new(:dummy, path)

      refute project.path?(Pathname(path.to_s[1..-2]))
      refute project.path?(path.to_s[1..-2])
    end
  end


  class ProjectSetTest < MiniTest::Test
    include TmpdirHelper

    def test_returns_current_project_by_matching_its_path_with_pwd
      in_tmpdir 'folder_two' do |basedir, dir_two|
        dir_one = Pathname(basedir) + 'folder_one'
        proj_one = Project.new(:one, dir_one)
        proj_two = Project.new(:two, dir_two)

        projects = ProjectSet.new([proj_one, proj_two])

        refute_nil projects.current, 'Should have returned a project'
        assert_equal proj_two, projects.current
      end
    end

    def test_returns_current_project_if_pwd_is_a_subdir
      in_tmpdir 'folder_one/subdir' do |basedir|
        dir_one = Pathname(basedir) + 'folder_one'
        dir_two = Pathname(basedir) + 'folder_two'
        proj_one = Project.new(:one, dir_one)
        proj_two = Project.new(:two, dir_two)

        projects = ProjectSet.new([proj_one, proj_two])

        refute_nil projects.current, 'Should have returned a project'
        assert_equal proj_one, projects.current
      end
    end

    def test_returns_nil_if_pwd_does_not_match_project_path
      in_tmpdir 'folder_two' do |basedir|
        dir_one = Pathname(basedir) + 'folder_one'
        proj_one = Project.new(:one, dir_one)

        projects = ProjectSet.new([proj_one])

        assert_nil projects.current, 'Should not have returned a project'
      end
    end

    def test_returns_nil_when_pwd_can_mistakenly_match_project_path
      in_tmpdir APP_FOLDERS.fetch(:sa) do |basedir|
        dir_one = Pathname(basedir) + APP_FOLDERS.fetch(:ss)
        proj_one = Project.new(:ss, dir_one)

        projects = ProjectSet.new([proj_one])

        assert_nil projects.current, 'Should not have returned a project'
      end
    end
  end


  class ProjectsBuilderTest < MiniTest::Test
    include TmpdirHelper

    def test_builds_all_projects
      folders = { sf: 'foundation', one: 'folder_one', two: 'folder_two' }

      in_tmpdir 'folder_two' do |basedir|
        ProjectSetBuilder.(folders: folders, basedir: basedir) do |projects|
          dir_one = Pathname(basedir) + 'folder_one'
          dir_two = Pathname(basedir) + 'folder_two'
          proj_two = Project.new(:two, dir_two)

          expected_projects = ProjectSet.new([
            Project.new(:one, dir_one),
            proj_two,
            Project.new(:sf, Pathname(basedir) + 'foundation')
          ])

          assert_equal expected_projects, projects
        end
      end
    end

    def test_builds_one_project_but_includes_foundation
      folders = { sf: 'foundation', one: 'folder_one', two: 'folder_two' }

      in_tmpdir 'folder_one' do |basedir|
        kwargs = { only: 'one', folders: folders, basedir: basedir }

        ProjectSetBuilder.(**kwargs) do |projects|
          foundation_dir = Pathname(basedir) + 'foundation'
          foundation_proj = Project.new(:sf, foundation_dir)
          dir_one = Pathname(basedir) + 'folder_one'
          proj_one = Project.new(:one, dir_one)

          assert_equal ProjectSet.new([foundation_proj, proj_one]), projects
        end
      end
    end

    def test_builds_some_projects
      folders = { sf: 'foundation', one: 'folder_one', two: 'folder_two' }

      in_tmpdir 'folder_one' do |basedir|
        kwargs = { only: 'one,sf', folders: folders, basedir: basedir }

        ProjectSetBuilder.(**kwargs) do |projects|
          foundation_dir = Pathname(basedir) + 'foundation'
          foundation_proj = Project.new(:sf, foundation_dir)
          dir_one = Pathname(basedir) + 'folder_one'
          proj_one = Project.new(:one, dir_one)

          assert_equal ProjectSet.new([foundation_proj, proj_one]), projects
        end
      end
    end
  end


  class MatchLineFileWriterTest < Minitest::Test
    include TmpdirHelper

    def test_yields_the_matched_lineno_plus_lines_and_writes_them_to_disk
      contents = "One\nTwo Three\nFour\nFive"

      in_tmpdir do |tmpdir|
        file = tmpdir + 'fixture.txt'
        file.write contents

        MatchLineFileWriter.new(file).(ref_line: /Three/) do |no, lines|
          assert_equal 1, no
          assert_equal contents.split("\n"), lines

          lines[no].gsub! 'Two Three', 'Six'
          lines
        end

        assert_equal "One\nSix\nFour\nFive\n", file.read
      end
    end
  end


  class BumpCommandEndToEnd < Minitest::Test
    include TmpdirHelper
    include CmdHelper
    include BumpAssertions

    def test_bumps_current_project_and_commits_staging_area
      GitFixtureCreator.create do |basedir, projects|
        cd_dir basedir + APP_FOLDERS.fetch(:ss) do |repo_dir|
          assert_equal 1, projects[:ss].commit_count

          cmd 'touch fixture_1'
          cmd 'touch fixture_2'

          projects[:ss].git! 'add fixture_1 fixture_2'
          projects[:ss].git! "commit -m 'Commited files'"

          cmd "echo 'modification_1' >> fixture_1"
          cmd "echo 'modification_2' >> fixture_2"
          cmd 'touch non_tracked'

          projects[:ss].git! 'add fixture_1'
          projects[:ss].git! 'add non_tracked'

          output = stack_cmd 'bump', basedir: basedir
          files_of_last_commit = %w(Gemfile Gemfile.lock fixture_1 non_tracked)

          assert_equal ['Bumping SS'], output.scan(/Bumping .+/)
          assert_equal 3, projects[:ss].commit_count
          assert_equal 'fixture_2', projects[:ss].diff_name_only
          assert_equal files_of_last_commit, projects[:ss].files_of_last_commit
          assert_not_bump projects.except(:ss, :sf)
        end
      end
    end

    def test_commits_foundation_bumps_current_project_and_commits_staging_area
      GitFixtureCreator.create do |basedir, projects|
        cd_dir basedir + APP_FOLDERS.fetch(:ss) do |repo_dir|
          cmd "touch ../#{APP_FOLDERS.fetch(:sf)}/sf_fixture"
          cmd 'touch ss_fixture'

          projects[:sf].git! 'add sf_fixture'
          projects[:ss].git! 'add ss_fixture'

          output = stack_cmd 'bump -m "My message"', basedir: basedir
          files_of_last_commit = ['Gemfile', 'Gemfile.lock', 'ss_fixture']

          assert_equal(
            ['Commiting SF', 'Bumping SS'],
            output.scan(/(Bumping .+|Commiting .+)/).flatten
          )
          assert_bump(
            projects.only(:ss),
            message: 'My message',
            ref: projects[:sf].ref,
            branch: 'master'
          )
          assert_equal files_of_last_commit, projects[:ss].files_of_last_commit
          assert_equal 2, projects[:sf].commit_count
          assert_equal 'My message', projects[:sf].last_commit_message
          assert_equal ['sf_fixture'], projects[:sf].files_of_last_commit
          assert_not_bump projects.except(:ss, :sf)
        end
      end
    end

    def test_bumps_foundation_in_all_projects_at_develop_branch
      GitFixtureCreator.create do |basedir, projects|
        cd_dir basedir + APP_FOLDERS.fetch(:ss) do |repo_dir|
          output = stack_cmd 'bump -a', basedir: basedir

          assert_operator output.scan(/Bumping .+/).count, :>, 2
          assert_not_bump projects.only(:sf)
          assert_bump(
            projects.except(:sf),
            ref: projects[:sf].ref,
            branch: 'master',
            message: 'Bump foundation'
          )
        end
      end
    end

    def checkout(projects, branch:)
      projects.each { |p| p.git! "checkout -b #{branch}" }
    end

    def test_bumps_foundation_in_all_projects_of_same_branch_name
      GitFixtureCreator.create do |basedir, projects|
        cd_dir basedir + APP_FOLDERS.fetch(:ss) do |repo_dir|
          checkout projects.only(:sf, :sc, :ss), branch: 'new'

          output = stack_cmd('bump -a', basedir: basedir)

          assert_equal ['Bumping SS', 'Bumping SC'], output.scan(/Bumping .+/)
          assert_bump(
            projects.with_branch('new').except(:sf),
            ref: projects[:sf].ref,
            branch: 'new',
            message: 'Bump foundation'
          )
          assert_not_bump(
            projects.with_branch_different_from('new').including(projects[:sf])
          )
        end
      end
    end

    def test_bumps_foundation_on_current_project_with_custom_message
      GitFixtureCreator.create do |basedir, projects|
        cd_dir basedir + APP_FOLDERS.fetch(:ss) do |repo_dir|
          checkout projects.only(:sf, :ss), branch: 'my-new'

          output = stack_cmd 'bump -m "My message"', basedir: basedir

          assert_equal ['Bumping SS'], output.scan(/Bumping .+/)
          assert_bump(
            projects.with_branch('my-new').except(:sf),
            ref: projects[:sf].ref,
            branch: 'my-new',
            message: 'My message'
          )
          assert_not_bump(
            projects.with_branch_different_from('my-new').including(projects[:sf])
          )
        end
      end
    end
  end


  class BranchCommandEndToEnd < Minitest::Test
    include TmpdirHelper
    include CmdHelper
    include BumpAssertions

    def test_changes_foundation_ref_without_commiting
      GitFixtureCreator.create do |basedir, projects|
        cd_dir basedir + APP_FOLDERS.fetch(:ss) do |repo_dir|
          assert_equal 1, projects[:ss].commit_count

          output = stack_cmd 'changeref', basedir: basedir

          assert_match(/Changed foundation/, output)
          refute projects[:ss].working_directory_clean?
          assert_equal ['Gemfile', 'Gemfile.lock'], projects[:ss].modified_files
          assert_ref_change projects[:ss], ref: projects[:sf].ref, branch: 'master'
          assert_not_bump projects
        end
      end
    end

    def collect_branches(projects)
      projects.map { |proj| [proj.id.to_sym, proj.branch] }.to_h
    end

    def test_creates_a_branch_and_switches_back_to_prev_branch_in_all_projects
      GitFixtureCreator.create do |basedir, projects|
        Dir.chdir basedir + APP_FOLDERS.fetch(:ss) do
          output = stack_cmd 'branch -c my-new-branch', basedir: basedir

          assert_match(/my-new-branch/, output)
          assert_equal ['my-new-branch'], collect_branches(projects).values.uniq

          stack_cmd 'branch master', basedir: basedir

          assert_equal ['master'], collect_branches(projects).values.uniq
        end
      end
    end

    def test_does_not_switch_to_a_branch_when_it_does_not_exist
      GitFixtureCreator.create do |basedir, projects|
        cd_dir basedir + APP_FOLDERS.fetch(:ss) do
          output = stack_cmd 'branch invalid', basedir: basedir

          assert_equal "No branch 'invalid' exists in any given project", output
          assert_equal ['master'], collect_branches(projects).values.uniq
        end
      end
    end

    def test_only_switches_to_branch_where_it_exists
      GitFixtureCreator.create do |basedir, projects|
        cd_dir basedir + APP_FOLDERS.fetch(:ss) do
          projects[:sf].git! 'checkout -b new'
          projects[:ss].git! 'checkout -b new'

          output = stack_cmd 'branch new', basedir: basedir

          assert_match(/projects: SF, SS\z/, output)
        end
      end
    end

    def test_creates_a_branch_in_some_projects
      GitFixtureCreator.create do |basedir, projects|
        cd_dir basedir + APP_FOLDERS.fetch(:ss) do
          output = stack_cmd 'branch -c -o sf,ss my-new-branch', basedir: basedir
          branches = collect_branches(projects)

          assert_match(/my-new-branch/, output)
          assert_match(/SF, SS/, output)
          assert_equal 'my-new-branch', branches.delete(:sf)
          assert_equal 'my-new-branch', branches.delete(:ss)
          assert_equal ['master'], branches.values.uniq
        end
      end
    end
  end
end


stack.define_command do
  name 'self_test'
  summary "run this command's test suite"

  run do |_, _|
    ENV['APP_ENV'] = 'test'

    run_test_suite.()
  end
end


## INITIALIZATION ##


if $0 == __FILE__
  if !ARGV.include?('self_test') && !ProjectPathSet.new.valid_current_path?
    abort "Are you in a stack project? Did you set STACK_PATH correctly?"
  end

  if ENV['APP_ENV'] == 'test' && !ENV['STACK_PATH'].to_s.start_with?(File.realpath(Dir.tmpdir))
    abort 'STACK_PATH is set incorrectly for test environment'
  end

  ARGV.dup.tap do |args|
    ARGV.clear

    begin
      stack.run(args)
    rescue StackError => e
      abort e.message
    end
  end
end


__END__
FILESTART: Gemfile
source 'http://rubygems.org'

ruby '2.1.6'

gem 'rails', '4.1.9'

gem 'stack_foundation',
  branch: '__gemfile_branch__',
  git: 'https://123456:x-oauth-basic@github.com/stacksocial/stack-foundation.git'

gem 'sidekiq', '3.4.2'
FILESTART: Gemfile.lock
GIT
  remote: https://123456:x-oauth-basic@github.com/stacksocial/stack-foundation.git
  revision: __gemfile_lock_revision__
  branch: __gemfile_lock_branch__
  specs:
    stack_foundation (0.0.1)
    sidekiq

GIT
  remote: https://github.com/toptal/chewy.git
  revision: e58060c36d6ea977d27191ac5c3ccb274781e2e5
  branch: master
  specs:
    chewy (0.7.0)
      activesupport (>= 3.2)
      elasticsearch (>= 1.0.0)

GEM
  remote: http://rubygems.org/
  remote: https://rails-assets.org/
  specs:
    CFPropertyList (2.3.5)
    RedCloth (4.2.9)
    actionmailer (4.1.9)
FILESTART: COMMIT_EDITMSG

# The commit message you type here will be used in all projects. Gemfile and
# Gemfile.lock changes are made at the last minute and thus not shown here.
FILESTART: stack_command_description
This tool allows you to work with many Stack projects as if it was one project.

Basic example workflow:

  $ stack branch -c my-new-branch -o sf,ss
  Created branch 'my-new-branch' on projects: SF, SS

  $ cd ../stack-foundation
  $ touch new_file && git add new_file
  $
  $ cd ../stack-shops
  $ touch other_file && git add other_file
  $
  $ stack bump -m "Figure out how to commit this stuff for me"
  Bumping SF

  [my-new-branch ab5854e] Figure out how to commit this stuff for me
  1 file changed, 0 insertions(+), 0 deletions(-)

  create mode 100644 new_file

  Bumping SS

  [my-new-branch d7bd747] Figure out how to commit this stuff for me
  3 files changed, 3 insertions(+), 3 deletions(-)
  create mode 100644 new_file
  $
  $ stack branch develop
  Switched to branch 'develop' on projects: SF, SS, SA, SC, GO
  $ stack branch my-new-branch
  Switched to branch 'my-new-branch' on projects: SF, SS
  $ stack push
  $ cd ../stack-foundation
  $ touch yet_another_file && git add yet_another_file
  $ stack bump
FILESTART: bump_command_description
- Can be used as a substitute to git commit, but it acts on all projects while also bumping foundation.

- It does what you expect in each situation. If there are files in the staging area, they will be commited in all affected projects. If not, it will just bump foundation if applicable.

- Acts on the current project + foundation, unless you use --all.

- Branches must have the same name for this to work.

- The same commit message is used in all affected projects.

- If a message is not specified, a default one is used. If there are staged changes in foundation, we ask you to provide a message (because in that case we are not "*just* bumping it).
